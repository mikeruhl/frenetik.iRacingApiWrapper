using ApiCoverageAnalyzer.Analyzers;
using ApiCoverageAnalyzer.Utilities;
using Frenetik.iRacingApiWrapper.Models;
using Microsoft.Extensions.Logging;
using System.Reflection;

namespace ApiCoverageAnalyzer.Comparers;

/// <summary>
/// Compares API endpoints to wrapper methods
/// </summary>
public class EndpointComparer(
    ILogger<EndpointComparer> logger)
{
    private const string Iso8601DateIndicator = "ISO-8601 UTC time zero offset";

    /// <summary>
    /// Compare API endpoints to wrapper methods and find matches
    /// </summary>
    /// <param name="apiEndpoints">API endpoints from GetDoc()</param>
    /// <param name="pathToMethodMap">Map of API paths to wrapper methods (from IL extraction)</param>
    public EndpointAnalysisResult Compare(
        Dictionary<string, EndpointDetails> apiEndpoints,
        Dictionary<string, MethodInfo> pathToMethodMap)
    {
        var result = new EndpointAnalysisResult
        {
            TotalEndpoints = apiEndpoints.Count
        };

        foreach (var (endpointKey, endpointDetails) in apiEndpoints)
        {
            // Try to match endpoint by its link (actual path)
            var matchedMethod = FindMatchingMethod(endpointKey, endpointDetails.Link, pathToMethodMap);

            if (matchedMethod is not null)
            {
                result.MatchedEndpoints[endpointKey] = new MatchedEndpoint
                {
                    EndpointPath = endpointKey,
                    MethodName = matchedMethod.Name,
                    Method = matchedMethod,
                    Parameters = endpointDetails.Parameters.ToDictionary(
                        p => p.Key,
                        p => new EndpointParameter
                        {
                            // Override type to datetime if note indicates ISO-8601 date
                            Type = IsDateType(p.Value.Note) ? "datetime" : p.Value.Type,
                            Note = p.Value.Note,
                            Required = p.Value.Required
                        })
                };
                result.CoveredEndpoints++;
            }
            else
            {
                result.MissingEndpoints.Add(endpointKey);
                logger.LogWarning("No wrapper method found for endpoint: {Endpoint} (link: {Link})",
                    endpointKey, endpointDetails.Link);
            }
        }

        result.CoveragePercentage = result.TotalEndpoints > 0
            ? (double)result.CoveredEndpoints / result.TotalEndpoints * 100.0
            : 100.0;

        return result;
    }

    private static bool IsDateType(string note)
    {
        return !string.IsNullOrEmpty(note) && note.Contains(Iso8601DateIndicator, StringComparison.OrdinalIgnoreCase);
    }

    private MethodInfo? FindMatchingMethod(
        string endpointKey,
        string endpointLink,
        Dictionary<string, MethodInfo> pathToMethodMap)
    {
        // The pathToMethodMap is keyed by actual API paths extracted from IL
        // Try direct path matching with various formats

        logger.LogDebug("Matching endpoint '{EndpointKey}' (link: '{EndpointLink}')",
            endpointKey, endpointLink);

        // Extract the path component from the URL (handles both relative paths and full URLs)
        var endpointPath = PathNormalizer.ExtractPathFromUrl(endpointLink);

        // Try all path variations generated by PathNormalizer
        foreach (var variation in PathNormalizer.GetPathVariations(endpointPath))
        {
            if (pathToMethodMap.TryGetValue(variation, out var method))
            {
                logger.LogDebug("  ✓ Match found: {MethodName} (variation: {Variation})", method.Name, variation);
                return method;
            }
        }

        // Log similar paths for debugging
        var normalizedPath = PathNormalizer.Normalize(endpointPath);
        var similarPaths = pathToMethodMap.Keys
            .Where(p =>
            {
                var parts = normalizedPath.Split('/');
                return PathNormalizer.Normalize(p).Contains(parts[^1]);
            })
            .Take(3)
            .ToList();

        if (similarPaths.Any())
        {
            logger.LogDebug("  ✗ No match found. Similar paths in map: {Paths}", string.Join(", ", similarPaths));
        }
        else
        {
            logger.LogDebug("  ✗ No match found for path: {Path}", endpointPath);
        }

        return null;
    }
}
